<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>{title}</title>
    <style>
        * { box-sizing: border-box; }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Roboto', 'Oxygen', 'Ubuntu', 'Cantarell', sans-serif;
            margin: 0;
            background: #f8fafc;
            color: #1e293b;
        }

        .header {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 2rem 0;
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1);
        }

        .header-content {
            max-width: 1200px;
            margin: 0 auto;
            padding: 0 2rem;
        }

        .header h1 { margin: 0; font-size: 2.5rem; font-weight: 700; }
        .header p { margin: 0.5rem 0 0 0; opacity: 0.9; font-size: 1.1rem; }

        .connection-status {
            margin-top: 1rem;
            padding: 0.5rem 1rem;
            border-radius: 6px;
            font-weight: 500;
        }

        .status-connecting { background: rgba(59, 130, 246, 0.2); color: #dbeafe; }
        .status-connected { background: rgba(16, 185, 129, 0.2); color: #dcfce7; }
        .status-error { background: rgba(239, 68, 68, 0.2); color: #fecaca; }

        .container {
            max-width: 1400px;
            margin: 0 auto;
            padding: 2rem;
            display: grid;
            grid-template-columns: 350px 1fr;
            gap: 2rem;
            height: calc(100vh - 200px);
        }

        .panel {
            background: white;
            border-radius: 12px;
            box-shadow: 0 1px 3px 0 rgba(0, 0, 0, 0.1), 0 1px 2px 0 rgba(0, 0, 0, 0.06);
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }

        .panel-header {
            padding: 1.5rem;
            border-bottom: 1px solid #e2e8f0;
            background: #f8fafc;
        }

        .panel-header h2 {
            margin: 0;
            font-size: 1.25rem;
            font-weight: 600;
            color: #1e293b;
        }

        .panel-content {
            flex: 1;
            overflow: auto;
        }

        .tool-list {
            list-style: none;
            padding: 0;
            margin: 0;
        }

        .tool-item {
            padding: 1rem 1.5rem;
            border-bottom: 1px solid #e2e8f0;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .tool-item:hover { background: #f1f5f9; }
        .tool-item.active { background: #dbeafe; border-right: 3px solid #3b82f6; }
        .tool-item:last-child { border-bottom: none; }

        .tool-name {
            font-weight: 600;
            color: #1e293b;
            font-family: 'SF Mono', 'Monaco', 'Inconsolata', 'Roboto Mono', monospace;
        }

        .tool-description {
            font-size: 0.875rem;
            color: #64748b;
            margin-top: 0.25rem;
            line-height: 1.4;
        }

        .inspector-content {
            padding: 1.5rem;
        }

        .tool-header {
            margin-bottom: 2rem;
            padding-bottom: 1rem;
            border-bottom: 1px solid #e2e8f0;
        }

        .tool-title {
            font-size: 1.5rem;
            font-weight: 700;
            color: #1e293b;
            font-family: 'SF Mono', 'Monaco', 'Inconsolata', 'Roboto Mono', monospace;
            margin: 0;
        }

        .tool-desc {
            color: #64748b;
            margin: 0.5rem 0 0 0;
            line-height: 1.6;
        }

        .parameters-section {
            margin-bottom: 2rem;
        }

        .section-title {
            font-size: 1.1rem;
            font-weight: 600;
            color: #374151;
            margin: 0 0 1rem 0;
        }

        .form-group {
            margin-bottom: 1.5rem;
        }

        .form-label {
            display: block;
            font-weight: 500;
            margin-bottom: 0.5rem;
            color: #374151;
        }

        .param-name {
            font-family: 'SF Mono', 'Monaco', 'Inconsolata', 'Roboto Mono', monospace;
            font-weight: 600;
        }

        .required { color: #ef4444; }
        .type-hint {
            font-size: 0.75rem;
            color: #6b7280;
            font-style: italic;
            margin-left: 0.5rem;
        }

        .param-description {
            font-size: 0.875rem;
            color: #6b7280;
            margin-top: 0.25rem;
        }

        .form-input, .form-textarea, .form-select {
            width: 100%;
            padding: 0.75rem;
            border: 1px solid #d1d5db;
            border-radius: 6px;
            font-size: 0.875rem;
            transition: border-color 0.2s ease;
        }

        .form-input:focus, .form-textarea:focus, .form-select:focus {
            outline: none;
            border-color: #3b82f6;
            box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.1);
        }

        .form-textarea {
            min-height: 100px;
            font-family: 'SF Mono', 'Monaco', 'Inconsolata', 'Roboto Mono', monospace;
            resize: vertical;
        }

        .btn {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 0.75rem 1.5rem;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            font-weight: 500;
            font-size: 0.875rem;
            transition: all 0.2s ease;
        }

        .btn:hover {
            transform: translateY(-1px);
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1);
        }

        .btn:disabled {
            background: #9ca3af;
            cursor: not-allowed;
            transform: none;
            box-shadow: none;
        }

        .output {
            background: #1e293b;
            color: #f1f5f9;
            padding: 1.5rem;
            border-radius: 8px;
            font-family: 'SF Mono', 'Monaco', 'Inconsolata', 'Roboto Mono', monospace;
            white-space: pre-wrap;
            min-height: 200px;
            margin-top: 2rem;
            border: 1px solid #334155;
        }

        .loading { color: #94a3b8; font-style: italic; }
        .error { background: #7f1d1d; color: #fecaca; border-color: #b91c1c; }
        .success { background: #064e3b; color: #a7f3d0; border-color: #047857; }

        .empty-state {
            text-align: center;
            padding: 3rem 1.5rem;
            color: #64748b;
        }

        .empty-state h3 {
            margin: 0 0 0.5rem 0;
            color: #374151;
        }

        @media (max-width: 768px) {
            .container {
                grid-template-columns: 1fr;
                height: auto;
            }
        }
    </style>
</head>
<body>
    <div class="header">
        <div class="header-content">
            <h1>{title}</h1>
            <p>Inspect and test MCP tools directly in your browser</p>
            <div id="connectionStatus" class="connection-status status-connecting">
                üîÑ Connecting to MCP server...
            </div>
        </div>
    </div>

    <div class="container">
        <div class="panel">
            <div class="panel-header">
                <h2>Available Tools</h2>
            </div>
            <div class="panel-content">
                <ul id="toolList" class="tool-list">
                    <li class="loading" style="padding: 1rem 1.5rem;">Loading tools...</li>
                </ul>
            </div>
        </div>

        <div class="panel">
            <div class="panel-header">
                <h2>Tool Inspector</h2>
            </div>
            <div class="panel-content">
                <div id="toolInspector" class="inspector-content">
                    <div class="empty-state">
                        <h3>Select a tool to inspect</h3>
                        <p>Choose a tool from the list on the left to view its details and test it.</p>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Load MCP SDK from CDN -->
    <script type="module">
        // Import MCP SDK components
        let mcpClient = null;
        let currentTool = null;
        let tools = [];

        // HTTP transport for MCP with session support
        class MCPHttpTransport {
            constructor(url) {
                this.url = url;
                this.sessionId = null;
            }

            async send(request) {
                try {
                    const headers = {
                        'Content-Type': 'application/json',
                        'Accept': 'application/json, text/event-stream',
                    };

                    // Include session ID if we have one
                    if (this.sessionId) {
                        headers['mcp-session-id'] = this.sessionId;
                    }

                    const response = await fetch(this.url, {
                        method: 'POST',
                        headers: headers,
                        body: JSON.stringify(request)
                    });

                    // Capture session ID from response headers
                    const mcpSessionId = response.headers.get('mcp-session-id');
                    if (mcpSessionId) {
                        this.sessionId = mcpSessionId;
                    }

                    if (!response.ok) {
                        // If we get a 400 "Missing session ID" error, capture session ID and signal for initialization
                        if (response.status === 400) {
                            const errorText = await response.text();
                            if (errorText.includes('Missing session ID')) {
                                console.log('üîë Server requires session - captured session ID:', this.sessionId);
                                return { error: { code: -32600, message: 'Session required' } };
                            }
                        }
                        throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                    }

                    const responseText = await response.text();

                    // Handle Server-Sent Events format
                    if (responseText.startsWith('event: message')) {
                        const lines = responseText.split('\n');
                        for (const line of lines) {
                            if (line.startsWith('data: ')) {
                                return JSON.parse(line.substring(6));
                            }
                        }
                        throw new Error('No data found in SSE response');
                    } else {
                        // Handle regular JSON format
                        return JSON.parse(responseText);
                    }
                } catch (error) {
                    console.error('MCP transport error:', error);
                    throw error;
                }
            }
        }

        // MCP Client implementation with session support
        class MCPClient {
            constructor(transport) {
                this.transport = transport;
                this.requestId = 0;
                this.initialized = false;
            }

            async request(method, params = {}) {
                const request = {
                    jsonrpc: '2.0',
                    id: ++this.requestId,
                    method: method,
                    params: params
                };

                const response = await this.transport.send(request);

                // Handle session required error by initializing
                if (response.error && response.error.message === 'Session required') {
                    console.log('Initializing MCP session...');
                    await this.initialize();
                    // Retry the original request
                    return await this.request(method, params);
                }

                if (response.error) {
                    throw new Error(response.error.message || 'MCP request failed');
                }

                return response.result;
            }

            async initialize() {
                if (this.initialized) return;

                // Step 1: Send initialize request
                const initRequest = {
                    jsonrpc: '2.0',
                    id: ++this.requestId,
                    method: 'initialize',
                    params: {
                        protocolVersion: '2024-11-05',
                        capabilities: {
                            roots: {
                                listChanged: false
                            }
                        },
                        clientInfo: {
                            name: 'MCP Web Inspector',
                            version: '1.0.0'
                        }
                    }
                };

                const response = await this.transport.send(initRequest);

                if (response.error) {
                    throw new Error(`Initialization failed: ${response.error.message}`);
                }

                // Step 2: Send initialized notification (required for stateful servers)
                const initNotification = {
                    jsonrpc: '2.0',
                    method: 'notifications/initialized',
                    params: {}
                };

                try {
                    await this.transport.send(initNotification);
                    console.log('‚úÖ MCP session initialized and ready');
                } catch (notificationError) {
                    // Some servers might not support this notification, continue anyway
                    console.warn('‚ö†Ô∏è Initialized notification failed, but continuing:', notificationError.message);
                }

                this.initialized = true;
                return response.result;
            }

            async listTools() {
                const result = await this.request('tools/list');
                return result;
            }

            async callTool(name, args) {
                const result = await this.request('tools/call', { name, arguments: args });
                return result;
            }
        }

        async function initializeMCP() {
            const statusEl = document.getElementById('connectionStatus');

            try {
                // Create MCP client with HTTP transport
                const transport = new MCPHttpTransport('{mcp_url}');
                mcpClient = new MCPClient(transport);

                statusEl.className = 'connection-status status-connecting';
                statusEl.innerHTML = 'üîÑ Initializing MCP session...';

                // Always initialize session first for maximum compatibility
                console.log('üîÑ Attempting MCP session initialization...');
                await mcpClient.initialize();

                statusEl.innerHTML = 'üîÑ Loading tools...';

                // Test connection by listing tools
                const result = await mcpClient.listTools();
                tools = result.tools || [];

                statusEl.className = 'connection-status status-connected';
                statusEl.innerHTML = `‚úÖ Connected to MCP server (${tools.length} tools)`;

                renderToolList();

            } catch (error) {
                console.error('Failed to connect to MCP server:', error);
                statusEl.className = 'connection-status status-error';
                statusEl.innerHTML = `‚ùå Connection failed: ${error.message}`;

                // Show detailed error information
                document.getElementById('toolList').innerHTML = `
                    <li style="padding: 1rem 1.5rem; color: #ef4444;">
                        <strong>Connection Error:</strong><br>
                        ${error.message}<br><br>
                        <strong>Debug Info:</strong><br>
                        ‚Ä¢ URL: {mcp_url}<br>
                        ‚Ä¢ Session ID: ${mcpClient?.transport?.sessionId || 'None'}<br>
                        ‚Ä¢ Browser: ${navigator.userAgent}<br><br>
                        <em>Check browser console for more details</em>
                    </li>
                `;
            }
        }

        function renderToolList() {
            const toolList = document.getElementById('toolList');

            if (tools.length === 0) {
                toolList.innerHTML = '<li style="padding: 1rem 1.5rem; color: #64748b;">No tools available</li>';
                return;
            }

            toolList.innerHTML = tools.map(tool => `
                <li class="tool-item" onclick="selectTool('${tool.name}', ${JSON.stringify(tool).replace(/"/g, '&quot;')})">
                    <div class="tool-name">${tool.name}</div>
                    <div class="tool-description">${tool.description || 'No description available'}</div>
                </li>
            `).join('');
        }

        window.selectTool = function(toolName, toolData) {
            // Update UI
            document.querySelectorAll('.tool-item').forEach(item => item.classList.remove('active'));
            event.currentTarget.classList.add('active');

            // Parse tool data
            currentTool = typeof toolData === 'string' ? JSON.parse(toolData) : toolData;
            renderToolInspector();
        }

        function renderToolInspector() {
            if (!currentTool) return;

            const inspector = document.getElementById('toolInspector');
            const schema = currentTool.inputSchema || {};
            const properties = schema.properties || {};
            const required = schema.required || [];

            const parameters = Object.entries(properties).map(([name, prop]) => ({
                name,
                type: getTypeFromSchema(prop),
                required: required.includes(name),
                description: prop.description || '',
                schema: prop
            }));

            inspector.innerHTML = `
                <div class="tool-header">
                    <h3 class="tool-title">${currentTool.name}</h3>
                    <p class="tool-desc">${currentTool.description || 'No description available'}</p>
                </div>

                ${parameters.length > 0 ? `
                    <div class="parameters-section">
                        <h4 class="section-title">Parameters</h4>
                        <form id="toolForm" onsubmit="callTool(event)">
                            ${parameters.map(param => `
                                <div class="form-group">
                                    <label class="form-label">
                                        <span class="param-name">${param.name}</span>
                                        ${param.required ? '<span class="required">*</span>' : ''}
                                        <span class="type-hint">${param.type}</span>
                                    </label>
                                    ${param.description ? `<div class="param-description">${param.description}</div>` : ''}
                                    ${renderParameterInput(param)}
                                </div>
                            `).join('')}

                            <button type="submit" class="btn" id="callBtn">
                                üöÄ Call Tool
                            </button>
                        </form>
                    </div>
                ` : `
                    <div class="parameters-section">
                        <h4 class="section-title">Parameters</h4>
                        <p style="color: #64748b; font-style: italic;">This tool takes no parameters.</p>
                        <button onclick="callTool()" class="btn" id="callBtn">
                            üöÄ Call Tool
                        </button>
                    </div>
                `}

                <div id="output" class="output" style="display: none;"></div>
            `;
        }

        function getTypeFromSchema(schema) {
            if (schema.type) {
                if (schema.type === 'array' && schema.items) {
                    return `array<${getTypeFromSchema(schema.items)}>`;
                }
                return schema.type;
            }
            if (schema.enum) {
                return `enum: ${schema.enum.join(' | ')}`;
            }
            return 'any';
        }

        function renderParameterInput(param) {
            const { schema } = param;

            if (schema.enum) {
                const options = schema.enum.map(value =>
                    `<option value="${JSON.stringify(value).slice(1, -1)}">${value}</option>`
                ).join('');
                return `<select class="form-select" name="${param.name}" ${param.required ? 'required' : ''}>
                    <option value="">Select...</option>
                    ${options}
                </select>`;
            }

            if (param.type === 'boolean') {
                return `<select class="form-select" name="${param.name}" ${param.required ? 'required' : ''}>
                    <option value="">Select...</option>
                    <option value="true">true</option>
                    <option value="false">false</option>
                </select>`;
            }

            if (param.type.includes('array') || param.type === 'object') {
                const placeholder = param.type.includes('array') ? '["item1", "item2"]' : '{"key": "value"}';
                return `<textarea class="form-textarea" name="${param.name}"
                    placeholder="Enter JSON: ${placeholder}"
                    ${param.required ? 'required' : ''}></textarea>`;
            }

            if (param.type === 'number' || param.type === 'integer') {
                return `<input type="number" class="form-input" name="${param.name}"
                    ${param.required ? 'required' : ''} />`;
            }

            return `<input type="text" class="form-input" name="${param.name}"
                ${param.required ? 'required' : ''} />`;
        }

        window.callTool = async function(event) {
            if (event) {
                event.preventDefault();
            }

            const callBtn = document.getElementById('callBtn');
            const output = document.getElementById('output');

            output.style.display = 'block';
            callBtn.disabled = true;
            callBtn.textContent = '‚è≥ Calling...';
            output.textContent = 'Executing tool...';
            output.className = 'output loading';

            try {
                let params = {};

                // Get form data if form exists
                const form = document.getElementById('toolForm');
                if (form) {
                    const formData = new FormData(form);

                    for (const [key, value] of formData.entries()) {
                        if (value === '') continue;

                        // Find parameter schema
                        const schema = currentTool.inputSchema?.properties?.[key];

                        // Parse based on type
                        if (schema?.type === 'boolean') {
                            params[key] = value === 'true';
                        } else if (schema?.type === 'number' || schema?.type === 'integer') {
                            params[key] = schema.type === 'integer' ? parseInt(value) : parseFloat(value);
                        } else if (schema?.type === 'array' || schema?.type === 'object') {
                            try {
                                params[key] = JSON.parse(value);
                            } catch (e) {
                                throw new Error(`Invalid JSON for parameter ${key}: ${e.message}`);
                            }
                        } else {
                            params[key] = value;
                        }
                    }
                }

                const result = await mcpClient.callTool(currentTool.name, params);

                output.textContent = JSON.stringify(result, null, 2);
                output.className = 'output success';

            } catch (error) {
                console.error('Tool call error:', error);
                output.textContent = `Error: ${error.message}`;
                output.className = 'output error';

            } finally {
                callBtn.disabled = false;
                callBtn.textContent = 'üöÄ Call Tool';
            }
        }

        // Initialize when page loads
        initializeMCP();
    </script>
</body>
</html>